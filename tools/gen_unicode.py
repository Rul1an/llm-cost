#!/usr/bin/env python3
import os
import urllib.request
from typing import List, Tuple, Dict, Set

# Configuration
UNICODE_VERSION = "15.0.0"
BASE_URL = f"https://www.unicode.org/Public/{UNICODE_VERSION}/ucd"
OUTPUT_FILE = "src/tokenizer/unicode_tables.zig"
DATA_DIR = "tools/unicode_data"

# Categories to extract
# L: Lu, Ll, Lt, Lm, Lo
# M: Mn, Mc, Me
# N: Nd, Nl, No
# P: Pc, Pd, Pe, Pf, Pi, Po
# S: Sc, Sk, Sm, So
# C: Cc, Cf, Cs, Co, Cn
CATEGORIES = {
    'L': ['Lu', 'Ll', 'Lt', 'Lm', 'Lo'],
    'M': ['Mn', 'Mc', 'Me'],
    'N': ['Nd', 'Nl', 'No'],
    'P': ['Pc', 'Pd', 'Pe', 'Pf', 'Pi', 'Po'],
    'S': ['Sc', 'Sk', 'Sm', 'So'],
    'C': ['Cc', 'Cf', 'Cs', 'Co', 'Cn'],
}

def download_file(filename: str):
    os.makedirs(DATA_DIR, exist_ok=True)
    path = os.path.join(DATA_DIR, filename)
    if not os.path.exists(path):
        url = f"{BASE_URL}/{filename}"
        print(f"Downloading {url}...")
        urllib.request.urlretrieve(url, path)
    return path

def parse_ranges(filepath: str, target_props: Set[str]) -> List[Tuple[int, int]]:
    """Parse UnicodeData.txt or PropList.txt style files."""
    ranges = []

    with open(filepath, 'r', encoding='utf-8') as f:
        for line in f:
            if '#' in line:
                line = line[:line.index('#')]
            line = line.strip()
            if not line:
                continue

            parts = [p.strip() for p in line.split(';')]
            if len(parts) < 2:
                continue

            # UnicodeData.txt format: CODE;NAME;CATEGORY;...
            # PropList.txt format: START..END; PROP

            code_part = parts[0]
            prop = parts[1] # For PropList

            # Handle UnicodeData.txt which puts Category in 2nd index (3rd col)
            if 'UnicodeData.txt' in filepath:
                prop = parts[2]

            if prop not in target_props:
                continue

            if '..' in code_part:
                start_hex, end_hex = code_part.split('..')
                start = int(start_hex, 16)
                end = int(end_hex, 16)
            else:
                start = int(code_part, 16)
                end = start

            ranges.append((start, end))

    return optimize_ranges(ranges)

def optimize_ranges(ranges: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    if not ranges:
        return []

    ranges.sort()
    optimized = []
    current_start, current_end = ranges[0]

    for start, end in ranges[1:]:
        if start <= current_end + 1:
            current_end = max(current_end, end)
        else:
            optimized.append((current_start, current_end))
            current_start, current_end = start, end

    optimized.append((current_start, current_end))
    return optimized

def generate_zig_code(tables: Dict[str, List[Tuple[int, int]]]):
    os.makedirs(os.path.dirname(OUTPUT_FILE), exist_ok=True)
    with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
        f.write(f"// DO NOT EDIT. Generated by tools/gen_unicode.py from Unicode {UNICODE_VERSION}\n")
        f.write("const std = @import(\"std\");\n\n")
        f.write("pub const CodePoint = u21;\n")
        f.write("pub const Range = struct { start: CodePoint, end: CodePoint };\n\n")

        f.write("inline fn inRanges(cp: CodePoint, ranges: []const Range) bool {\n")
        f.write("    var lo: usize = 0;\n")
        f.write("    var hi: usize = ranges.len;\n")
        f.write("    while (lo < hi) {\n")
        f.write("        const mid = lo + (hi - lo) / 2;\n")
        f.write("        const r = ranges[mid];\n")
        f.write("        if (cp < r.start) {\n")
        f.write("            hi = mid;\n")
        f.write("        } else if (cp > r.end) {\n")
        f.write("            lo = mid + 1;\n")
        f.write("        } else {\n")
        f.write("            return true;\n")
        f.write("        }\n")
        f.write("    }\n")
        f.write("    return false;\n")
        f.write("}\n\n")

        # Sort keys to keep output deterministic
        for name in sorted(tables.keys()):
            ranges = tables[name]
            f.write(f"pub const {name}_RANGES = [_]Range{{\n")
            for start, end in ranges:
                f.write(f"    .{{ .start = 0x{start:04X}, .end = 0x{end:04X} }},\n")
            f.write("};\n\n")

        # Helper functions
        # Map TABLE_NAME -> FunctionName
        helpers = {
            'LETTER': 'isLetter',
            'MARK': 'isMark',
            'NUMBER': 'isNumber',
            'PUNCT': 'isPunctuation',
            'SYMBOL': 'isSymbol',
            'OTHER': 'isOther',
            'WHITE_SPACE': 'isWhitespace',
            'LU': 'isLu',
            'LL': 'isLl',
            'LT': 'isLt',
            'LM': 'isLm',
            'LO': 'isLo',
        }

        for table_name, func_name in helpers.items():
            if table_name in tables:
                f.write(f"pub fn {func_name}(cp: CodePoint) bool {{\n")
                f.write(f"    return inRanges(cp, &{table_name}_RANGES);\n")
                f.write("}\n\n")

def main():
    ud_path = download_file("UnicodeData.txt")
    pl_path = download_file("PropList.txt")

    tables = {}

    # 1. Process UnicodeData.txt for General Categories
    print("Processing Categories...")

    # We want:
    # - Aggregates: Letter (L*), Mark (M*), Number (N*), Punct (P*), Symbol (S*), Other (C*)
    # - Specifics: Lu, Ll, Lt, Lm, Lo

    cat_mapping = {
        'L': 'LETTER',
        'M': 'MARK',
        'N': 'NUMBER',
        'P': 'PUNCT',
        'S': 'SYMBOL',
        'C': 'OTHER'
    }

    specific_cats = ['Lu', 'Ll', 'Lt', 'Lm', 'Lo']

    # To store ranges before optimization
    raw_tables = {k: [] for k in cat_mapping.values()}
    for sc in specific_cats:
        raw_tables[sc.upper()] = [] # LU, LL, etc.

    with open(ud_path, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if not line: continue
            parts = line.split(';')
            code = int(parts[0], 16)
            cat = parts[2]

            # Add to aggregate bucket
            main_cat = cat[0]
            if main_cat in cat_mapping:
                raw_tables[cat_mapping[main_cat]].append((code, code))

            # Add to specific bucket
            if cat in specific_cats:
                raw_tables[cat.upper()].append((code, code))

    for name, ranges in raw_tables.items():
        tables[name] = optimize_ranges(ranges)

    # 2. Process PropList.txt for White_Space
    print("Processing White_Space...")
    ws_ranges = parse_ranges(pl_path, {'White_Space'})
    tables['WHITE_SPACE'] = ws_ranges

    print(f"Generating {OUTPUT_FILE}...")
    generate_zig_code(tables)
    print("Done.")

if __name__ == "__main__":
    main()
